 * Add pendingWriteLock to lockmanager so that the read locks cannot starve out the write locks.
    * Write locks must wait for all the read locks to finish but if the user keeps adding read locks that never happens
    * ***!!! NEED TO CHECK IF THIS IS ACTUALLY NECESSARY 

 *** Document semantics for array change notification, definition of changed rectangles, etc. See notifications in x3d.hpp that are probably extraneous.
   Basically upon allocation the region is marked as "pending modification". Then any explicit modification (such as opencl write with dirty marking or
   explicit marking as modification clears the "pending modification" mark. When the array is marked as ready, any remaining "pending modifications"
   get turned into real notifications, invalidating any currently cached areas.
   Note that recording_storage_simple doesn't do any of this, and presumes if you cache something on a GPU and then write to it with the CPU, you
   will explicitly mark the region as CPU modified. 
 * Need to implement on-demand viewing/access methods a'la ProcExpr/ProcRGBA, high-level API that uses them.
 * Need to implement file i/o as well as socket/shared memory linkage to a remote recording database
 * Need to implement Python math functions. 
 * Need to add numpy dtypes for geometry_types to end of spatialnde2.i
 * In recmath_compute_resource.cpp make the exception handler for math
   functions return an empty recording rather than causing a hang

 * *** Does the graphics_storage need to trigger mark_as_invalid on non-GPU-generated sub-arrays when the recording is
  marked as ready??? Probably in case the array is already GPU-cached, the openclcachemanager may need to know that the
  relevent region is not valid on the GPU (or alternatively make sure that freeing an array previously present in the same
  location would have marked the relevant region as not valid on the GPU and than unallocated regions are never considered valid)

 * Dataguzzler-python module contexts precede recording data in the locking order. Make a hook for the dataguzzler-python module context switcher to call when switching into a context to check if any recording locks are held by the current thread, and diagnose the error. If this is not implemented there is the risk of hard-to-diagnose random deadlocks if dataguzzler-python modules make external calls to other modules while holding a spatialnde2 recording lock. (Similarly perhaps implement a wrapped lock within dataguzzler-python with similar behavior for intra-module locks?). So far none of this is an issue as spatialnde2 recording locks aren't exposed to Python at all. 
 
 * Consider the various scenarios relating to the transaction lock and dataguzzler-python
   module locks. One possibility is that the dataguzzler-python module could choose to have
   its module lock precede the transaction lock rather than vice-versa
 * Implement module lock dropping on StartTransaction()/EndTransaction()
 * How to deal with secondary threads in a module that use compatible contexts.
    * As long as the threads never attempt to call out to other modules everything is fine
    * If they do, so long as the main context thread never waits on the subthread without
      dropping its context lock, then everything is fine.
    * The problematic part is how to deal with AddQueryMetadatum functionality, which would
      be best automatic and implicit, but that creates problems in the subthread unless the
      main thread never waits without dropping context.
 * rec_display: Entire tree of display_info, channels, axes, units should be snapshotted and
    a copy rather than original passed alongside the display_requirements to the rendering chain.
    Then the rendering chain should queue up any changes so the compositor can issue them
    in the GUI thread. This will mean the rec_display structures no longer have to be thread
    safe. rec_display values (such as width, height, ColorIdx etc.) no longer need to be snapshotted
    in the compositor. Also provides a path for updates generated by on-demand channels and
    provides an architecture that can be easily ported over to (say) javascript for a web-based
    renderer. 
 * compositor/renderer example: Need to implement locking of any data arrays marked with
   requires_locking_xxxx

 * Reduce follower arrays so that math functions determining vertex arrays, normals,  etc. have to allocate their own. This will remove
   conflicts in case of different ondemand functions in different rss contexts calculating the same thing.
   (has already been partly done)

 * Fixup the typemaps so as to allow run-time addition of additional types
   * Include an inheritance tree so we can follow the tree to find a renderable
     class from a custom class that doesn't provide a renderer. 
 
 * Intelligent math function dispatch: Figuring out how many threads to delegate to a particular parallel algorithm

 * Windows shared memory implementation
 * Documentation
 * Synchronization of waveform database between multiple processes and/or multiple computers.
 * Improved bounding box library (bounding_hyperboxes.hpp)
 * C API wrapper for better ABI compatibility
 * Expression parser for defining math functions and/or coordinate transform operations. 

 * Need to implement scalar and waveform rendering modes in display_requirements.cpp

 * ***Check all calls to emplace() except display/rendering logic

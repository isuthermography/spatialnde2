 * Add pendingWriteLock to lockmanager so that the read locks cannot starve out the write locks.
    * Write locks must wait for all the read locks to finish but if the user keeps adding read locks that never happens
    * ***!!! NEED TO CHECK IF THIS IS ACTUALLY NECESSARY 

 *** Document semantics for array change notification, definition of changed rectangles, etc. See notifications in x3d.hpp that are probably extraneous.
   Basically upon allocation the region is marked as "pending modification". Then any explicit modification (such as opencl write with dirty marking or
   explicit marking as modification clears the "pending modification" mark. When the array is marked as ready, any remaining "pending modifications"
   get turned into real notifications, invalidating any currently cached areas.
   Note that recording_storage_simple doesn't do any of this, and presumes if you cache something on a GPU and then write to it with the CPU, you
   will explicitly mark the region as CPU modified. 

 * Need to add numpy dtypes for geometry_types to end of spatialnde2.i
 * openclcachemanager: _GetOpenCLSubBuffer gets locks without checking
   for requires_locking_read or requires_locking_write but _GetOpenCLBuffer
   does check requires_locking_read and requires_locking_write.
    *** In reality OpenCL requires locking in both cases, at least with
    the graphics_storage_manager. Need a protocol from the storage manager
    and cache manager and execution mechanism to determine whether
    to actually lock ***
 * In recmath_compute_resource.cpp make the exception handler for math
   functions return an empty recording rather than causing a hang

 * Dataguzzler-python module contexts precede recording data in the locking order. Make a hook for the dataguzzler-python module context switcher to call when switching into a context to check if any recording locks are held by the current thread, and diagnose the error. If this is not implemented there is the risk of hard-to-diagnose random deadlocks if dataguzzler-python modules make external calls to other modules while holding a spatialnde2 recording lock. (Similarly perhaps implement a wrapped lock within dataguzzler-python with similar behavior for intra-module locks?)

 * Reduce follower arrays so that math functions determining vertex arrays, normals,  etc. have to allocate their own. This will remove
   conflicts in case of different ondemand functions in different rss contexts calculating the same thing. 

 * Fixup the typemaps so as to allow run-time addition of additional types
   * Include an inheritance tree so we can follow the tree to find a renderable
     class from a custom class that doesn't provide a renderer. 
 
 * Intelligent math function dispatch: Figuring out how many threads to delegate to a particular parallel algorithm

 * Windows shared memory implementation
 * Documentation
 * Synchronization of waveform database between multiple processes and/or multiple computers.
 * Improved bounding box library (bounding_hyperboxes.hpp)
 * C API wrapper for better ABI compatibility
 * Expression parser for defining math functions and/or coordinate transform operations. 
 
